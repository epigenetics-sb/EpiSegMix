params {
    input                      = './samplesheet.csv'
    outdir                     = './results'
    schema                     = './schema_input.json'
    params_schema              = './schema_params.json'
    genome                     = 'hg38'
    binsize                    = 200
    merge                      = false
    states                     = 8
    chr_parameter_estimation   = 'pilot_hg38'
    publish_dir_mode           = 'copy'
    dist_histone               = 'NBI'
    dist_methyl                = 'BI'
    adjustment                 = 2
    iter                       = 200
    epsilon                    = 1
    decoding_algorithm          = 'viterbi'
    episegmix_mode             = 'standard'
    distributions              = ['NBI', 'SI', 'BNB']
    distributions_dna          = ['BI', 'BB']
    use_dna                    = false
    max_memory                 = '128.GB'
    max_cpus                   = 16
    max_time                   = '240.h'
}

plugins {
    id 'nf-schema@2.0.0' 
}

profiles {
    test {
        includeConfig 'conf/test.config'
    }

    docker {
        docker.enabled         = true
        docker.runOptions      = '-u $(id -u):$(id -g)'
        singularity.enabled    = false
        podman.enabled         = false
        shifter.enabled        = false
        charliecloud.enabled   = false
        apptainer.enabled      = false
    }
    singularity {
        singularity.enabled    = true
        singularity.autoMounts = true
        docker.enabled         = false
        podman.enabled         = false
        shifter.enabled        = false
        charliecloud.enabled   = false
        apptainer.enabled      = false
    }
    apptainer {
        apptainer.enabled      = true
        apptainer.autoMounts   = true
        singularity.enabled    = false
        docker.enabled         = false
        podman.enabled         = false
        shifter.enabled        = false
        charliecloud.enabled   = false
    }
    podman {
        podman.enabled         = true
        docker.enabled         = false
        singularity.enabled    = false
        shifter.enabled        = false
        charliecloud.enabled   = false
        apptainer.enabled      = false
    }
    shifter {
        shifter.enabled        = true
        docker.enabled         = false
        singularity.enabled    = false
        podman.enabled         = false
        charliecloud.enabled   = false
        apptainer.enabled      = false
    }
    charliecloud {
        charliecloud.enabled   = true
        docker.enabled         = false
        singularity.enabled    = false
        podman.enabled         = false
        shifter.enabled        = false
        apptainer.enabled      = false
    }

    standard {
        process.executor       = 'local'
    }
    slurm {
        process.executor       = 'slurm'
        executor.queueSize     = 10
        executor.submitRateLimit = '10 sec'
    }
    sge {
        process.executor = 'sge'
    }
    lsf {
        process.executor = 'lsf'
    }
}

process {
    errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
    maxRetries    = 1
    maxErrors     = '-1'

    withLabel: process_low {
        cpus   = { Math.min(2     * task.attempt, params.max_cpus as int) }
        memory = { (6.GB * task.attempt) < (params.max_memory as nextflow.util.MemoryUnit) ? (6.GB * task.attempt) : (params.max_memory as nextflow.util.MemoryUnit) }
        time   = { (4.h  * task.attempt) < (params.max_time as nextflow.util.Duration)     ? (4.h  * task.attempt) : (params.max_time as nextflow.util.Duration) }
    }
    withLabel: process_medium {
        cpus   = { Math.min(6     * task.attempt, params.max_cpus as int) }
        memory = { (36.GB * task.attempt) < (params.max_memory as nextflow.util.MemoryUnit) ? (36.GB * task.attempt) : (params.max_memory as nextflow.util.MemoryUnit) }
        time   = { (8.h   * task.attempt) < (params.max_time as nextflow.util.Duration)     ? (8.h   * task.attempt) : (params.max_time as nextflow.util.Duration) }
    }
    withLabel: process_high {
        cpus   = { Math.min(12    * task.attempt, params.max_cpus as int) }
        memory = { (72.GB * task.attempt) < (params.max_memory as nextflow.util.MemoryUnit) ? (72.GB * task.attempt) : (params.max_memory as nextflow.util.MemoryUnit) }
        time   = { (16.h  * task.attempt) < (params.max_time as nextflow.util.Duration)     ? (16.h  * task.attempt) : (params.max_time as nextflow.util.Duration) }
    }
    withLabel: process_single {
        cpus   = 1
        memory = { (6.GB * task.attempt) < (params.max_memory as nextflow.util.MemoryUnit) ? (6.GB * task.attempt) : (params.max_memory as nextflow.util.MemoryUnit) }
        time   = { (4.h  * task.attempt) < (params.max_time as nextflow.util.Duration)     ? (4.h  * task.attempt) : (params.max_time as nextflow.util.Duration) }
    }

    publishDir = [
        path: { "${params.outdir}/${task.process.tokenize(':')[-1].tokenize('_')[0].toLowerCase()}" },
        mode: params.publish_dir_mode,
    ]

    withName: CLEAN_AND_INDEX_BAM {
        container = "community.wave.seqera.io/library/samtools:1.22.1--eccb42ff8fb55509"
        publishDir = [
            path: { "${params.outdir}/IndexFiles/${meta.id}" },
            mode: params.publish_dir_mode,
            pattern: '*.{bam,bam.bai}'
        ]
    }
    withName: GENERATE_COUNT_MATRIX_BAM {
        container = "aaryanjaitly/episegmix_counts_container:latest"
        publishDir = [
            path: { "${params.outdir}/Counts/${meta.id}" },
            mode: params.publish_dir_mode,
            pattern: '**/*_refined_counts.txt',
            
        ]
    }
    withName: GENERATE_COUNT_MATRIX_BED {
        container = "biocontainers/biocontainers:v1.2.0_cv1"
        publishDir = [
            path: { "${params.outdir}/Counts/${meta.id}" },
            mode: params.publish_dir_mode,
            pattern: '**/*.tab',
        ]
    }
    withName: GENERATE_GENOME_BINS {
        container = "community.wave.seqera.io/library/bedtools:2.31.1--7c4ce4cb07c09ee4"
        publishDir = [
            path: { "${params.outdir}/References/${params.genome}" },
            mode: params.publish_dir_mode,
            pattern: "*.bed"
        ]
    }
    withName: GET_GENOME_CHROM_SIZE {
        container = "biocontainers/biocontainers:v1.2.0_cv1"
        publishDir = [
            path: { "${params.outdir}/References/${params.genome}" },
            mode: params.publish_dir_mode,
            pattern: "${params.genome}.chrom.sizes"
        ]

    }
    withName: MERGE_COUNTS {
        container = "community.wave.seqera.io/library/bedtools:2.31.1--7c4ce4cb07c09ee4"
        publishDir = [
            path: { "${params.outdir}/Counts/${meta.id}/MergedCounts" },
            mode: params.publish_dir_mode,
            pattern: "*_seg_tabs_counts.bed"
        ]
    }
    withName: SPLIT_MERGED_COUNTS {
        container = "biocontainers/biocontainers:v1.2.0_cv1"
        publishDir = [
            path: { "${params.outdir}/Counts/${meta.id}/BinnedCounts" },
            mode: params.publish_dir_mode
        ]
    }
    withName: '.*:EPISEGMIX_.*' {
        container = "aaryanjaitly/episegmix:new_plots"
    }
    withName: 'EPISEGMIX_.*_PREPARE' {
        publishDir = [ 
            path: { "${params.outdir}/EpiSegMix/${meta.id}/Models" },
            mode: params.publish_dir_mode,
            pattern: '*.{yaml,txt}' 
         ]
    }
    withName: 'EPISEGMIX_.*_TRAIN' {
        publishDir = [
            path: { "${params.outdir}/EpiSegMix/${meta.id}/Models" },
            mode: params.publish_dir_mode,
            pattern: '*.{json,log}'
        ]
    }
    withName: 'EPISEGMIX_.*_DECODE' {
        publishDir = [
            path: { "${params.outdir}/EpiSegMix/${meta.id}/Segmentation" },
            mode: params.publish_dir_mode,
            pattern: 'segmentation/*.{bed.gz,txt}',
            saveAs: { file -> file.tokenize('/').last() }
        ]
    }
    withName: 'EPISEGMIX_.*_REPORT' {
        publishDir = [
            path: { "${params.outdir}/EpiSegMix/${meta.id}/Plots" },
            mode: params.publish_dir_mode,
            pattern: '**/*.{png,html}', 
            saveAs: { file -> file.tokenize('/').last() }
        ]
    }

    withName: 'EPISEGMIX_DISTFIT_HISTONE_ASSESS' {
        publishDir = [
            path: { "${params.outdir}/EpiSegMix/${meta.id}/Fitting" },
            mode: params.publish_dir_mode,
            pattern: '*.yaml',
            saveAs: { file -> file.tokenize('/').last() }
        ]
    }

    withName: GENERATE_METHYLATION_BINS {
        container = "community.wave.seqera.io/library/bedtools:2.31.1--7c4ce4cb07c09ee4"
        publishDir = [
            path: { "${params.outdir}/Counts/${meta.id}/${meta.id}_${meta.modality}" },
            mode: params.publish_dir_mode
        ]
    }

    }

def trace_timestamp = new java.util.Date().format( 'yyyy-MM-dd_HH-mm-ss')
timeline {
    enabled = true
    file    = "${params.outdir}/pipeline_info/execution_timeline_${trace_timestamp}.html"
}
report {
    enabled = true
    file    = "${params.outdir}/pipeline_info/execution_report_${trace_timestamp}.html"
}
trace {
    enabled = true
    file    = "${params.outdir}/pipeline_info/execution_trace_${trace_timestamp}.txt"
}
dag {
    enabled = true
    file    = "${params.outdir}/pipeline_info/pipeline_dag_${trace_timestamp}.html"
}
